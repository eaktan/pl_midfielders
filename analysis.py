# -*- coding: utf-8 -*-
"""Project Data

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DJoRohR5g7qREWujqRNWjcQkLN9Rl-c-
"""

import pandas as pd
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
import numpy as np

# LOAD AND INITIAL CLEANING

df = pd.read_csv('pl_midfielders_master_combined.csv')
actual_names = df.iloc[0].values
df.columns = [actual_names[i] if "Unnamed" in df.columns[i] else df.columns[i] for i in range(len(df.columns))]
df = df.drop(df.index[0]).reset_index(drop=True)

# CONVERT NECESSARY COLUMNS TO NUMERIC

metrics = ['90s Played', 'npxG', 'xAG', 'KP', 'PPA', 'Tkl+Int', 'Blocks', 'Clr', 'PrgDist', '1/3', 'PrgP']
for col in metrics:
    df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)

# FILTER FOR CORE PLAYERS (>= 1000 Minutes)
core_df = df[df['90s Played'] >= (1000/90)].copy()

# CALCULATE PER 90 STATS (Normalization for playtime)
core_df['npxG_p90'] = core_df['npxG'] / core_df['90s Played']
core_df['xAG_p90'] = core_df['xAG'] / core_df['90s Played']
core_df['KP_p90'] = core_df['KP'] / core_df['90s Played']
core_df['PPA_p90'] = core_df['PPA'] / core_df['90s Played']
core_df['TklInt_p90'] = core_df['Tkl+Int'] / core_df['90s Played']
core_df['Blocks_p90'] = core_df['Blocks'] / core_df['90s Played']
core_df['Clr_p90'] = core_df['Clr'] / core_df['90s Played']
core_df['PrgDist_p90'] = core_df['PrgDist'] / core_df['90s Played']
core_df['FinalThird_p90'] = core_df['1/3'] / core_df['90s Played']
core_df['PrgP_p90'] = core_df['PrgP'] / core_df['90s Played']

# GENERATE THE THREE INDICES (0-100 Scale)
scaler = MinMaxScaler()

# Define the logic for each category
off_cols = ['npxG_p90', 'xAG_p90', 'KP_p90', 'PPA_p90']
def_cols = ['TklInt_p90', 'Blocks_p90', 'Clr_p90']
prg_cols = ['PrgDist_p90', 'FinalThird_p90', 'PrgP_p90']

# We fit the scaler on the whole 'core_df' to ensure the scale is consistent across all years
core_df['Offense_Index'] = scaler.fit_transform(core_df[off_cols]).mean(axis=1) * 100
core_df['Defense_Index'] = scaler.fit_transform(core_df[def_cols]).mean(axis=1) * 100
core_df['Progression_Index'] = scaler.fit_transform(core_df[prg_cols]).mean(axis=1) * 100

# RE-CREATE THE SEASONAL DICTIONARY
# This dictionary now contains the DataFrames with the new Index columns
seasonal_dfs = {season: core_df[core_df['Season'] == season].copy() for season in core_df['Season'].unique()}

seasonal_trends = core_df.groupby('Season')[['Offense_Index', 'Defense_Index', 'Progression_Index']].mean().reset_index()

# Visualization
plt.figure(figsize=(12, 6))
sns.lineplot(data=seasonal_trends, x='Season', y='Offense_Index', label='Offense', marker='o', color='blue')
sns.lineplot(data=seasonal_trends, x='Season', y='Defense_Index', label='Defense', marker='s', color='red')
sns.lineplot(data=seasonal_trends, x='Season', y='Progression_Index', label='Progression', marker='^', color='green')

plt.title('The Evolution of PL Midfielders (2017-2025)')
plt.ylabel('Average Index Value (0-100)')
plt.grid(True, linestyle='--', alpha=0.7)
plt.xticks(rotation=45)
plt.legend()
plt.tight_layout()
plt.show()

# List of sorted seasons
seasons = sorted(core_df['Season'].dropna().unique())

print(f"{'Comparison':<25} | {'Offense P':<10} | {'Defense P':<10} | {'Prog P':<10}")
print("-" * 65)

for i in range(len(seasons) - 1):
    s1, s2 = seasons[i], seasons[i+1]

    # Calculate T-tests for each index
    p_off = stats.ttest_ind(core_df[core_df['Season'] == s1]['Offense_Index'],
                            core_df[core_df['Season'] == s2]['Offense_Index'])[1]

    p_def = stats.ttest_ind(core_df[core_df['Season'] == s1]['Defense_Index'],
                            core_df[core_df['Season'] == s2]['Defense_Index'])[1]

    p_prg = stats.ttest_ind(core_df[core_df['Season'] == s1]['Progression_Index'],
                            core_df[core_df['Season'] == s2]['Progression_Index'])[1]

    print(f"{s1} vs {s2:<10} | {p_off:<10.4f} | {p_def:<10.4f} | {p_prg:<10.4f}")

# Define the two eras
s_start = '2017-2018'
s_end = '2024-2025'

print(f"{'Metric':<15} | {'Start Mean':<12} | {'End Mean':<12} | {'% Change':<10} | {'P-Value'}")
print("-" * 70)

for metric in ['Offense_Index', 'Defense_Index', 'Progression_Index']:
    m1 = seasonal_dfs[s_start][metric]
    m2 = seasonal_dfs[s_end][metric]

    mean1, mean2 = m1.mean(), m2.mean()
    p_val = stats.ttest_ind(m1, m2)[1]
    pct_change = ((mean2 - mean1) / mean1) * 100

    print(f"{metric:<15} | {mean1:<12.2f} | {mean2:<12.2f} | {pct_change:<+9.1f}% | {p_val:.4f}")

# GENERATE THE RAW COUNTS TABLE
# This gives the exact number of players per archetype for every year
archetype_counts = core_df.groupby(['Season', 'Archetype']).size().unstack(fill_value=0)

# CALCULATE YEAR-ON-YEAR DIFFERENCES (Season-to-Season)
# Shows the net gain or loss of each player type compared to the previous year
yoy_diff = archetype_counts.diff().fillna(0)

# START VS END COMPARISON (The Cumulative Shift)
seasons = sorted(core_df['Season'].dropna().unique())
s_start, s_end = seasons[0], seasons[-1]

start_row = archetype_counts.loc[s_start]
end_row = archetype_counts.loc[s_end]

# Create a Summary DataFrame for the Start vs End Comparison
comparison_summary = pd.DataFrame({
    'Start Count (2017-18)': start_row,
    'End Count (2024-25)': end_row
})

comparison_summary['Net Change'] = comparison_summary['End Count (2024-25)'] - comparison_summary['Start Count (2017-18)']
comparison_summary['% Growth'] = (comparison_summary['Net Change'] / comparison_summary['Start Count (2017-18)']) * 100

# HYPOTHESIS TESTING (Chi-Square for specific Archetype shifts)
# We use a Chi-Square test for each archetype to see if its proportion in the
# league changed significantly from start to end.
n_total_start = start_row.sum()
n_total_end = end_row.sum()

p_values = {}
for arch in archetype_counts.columns:
    # Contingency Table: [Success (This Arch), Failure (Other Archs)]
    obs = [[start_row[arch], n_total_start - start_row[arch]],
           [end_row[arch], n_total_end - end_row[arch]]]
    _, p, _, _ = stats.chi2_contingency(obs)
    p_values[arch] = round(p, 4)

comparison_summary['P-Value'] = pd.Series(p_values)

# --- DISPLAY RESULTS ---
print("--- TABLE 1: PLAYER COUNTS PER ARCHETYPE ---")
print(archetype_counts)

print("\n--- TABLE 2: YEAR-ON-YEAR CHANGES ---")
print(yoy_diff)

print(f"\n--- TABLE 3: FINAL COMPARISON ({s_start} vs {s_end}) ---")
print(comparison_summary)

# Prepare the data for plotting
# Convert the index (Season) to a column and 'melt' it for Seaborn
plot_data = archetype_counts.reset_index().melt(id_vars='Season', var_name='Archetype', value_name='Count')

# Create the Visualization
plt.figure(figsize=(14, 8))
sns.lineplot(data=plot_data, x='Season', y='Count', hue='Archetype', marker='o', linewidth=2.5)

plt.title('Evolution of Midfielder Archetypes (2017-2025)', fontsize=16, fontweight='bold')
plt.ylabel('Number of Players in the League', fontsize=12)
plt.xlabel('Season', fontsize=12)
plt.xticks(rotation=45)
plt.grid(True, linestyle='--', alpha=0.6)
plt.legend(title='Tactical Archetype', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.savefig('archetype_evolution.png')
plt.show()

# CREATE A RANKING SCORE FOR EACH ARCHETYPE
# We define what "Best" means for each specific role
def calculate_archetype_score(row):
    if row['Archetype'] == "Creative Engine":
        return row['Offense_Index'] + row['Progression_Index']
    elif row['Archetype'] == "Deep-Lying Progressor":
        return row['Defense_Index'] + row['Progression_Index']
    elif row['Archetype'] == "Midfield Anchor":
        return row['Defense_Index'] # Primarily focused on one task
    elif row['Archetype'] == "Modern Box-to-Box":
        return row['Offense_Index'] + row['Defense_Index'] + row['Progression_Index']
    else:
        return 0 # System Rotational players aren't ranked here

core_df['Performance_Score'] = core_df.apply(calculate_archetype_score, axis=1)

# EXTRACT TOP PLAYER PER ARCHETYPE PER YEAR
# We filter out "System Rotational" and group by Season and Archetype
top_players = (core_df[core_df['Archetype'] != "System Rotational"]
               .sort_values(['Season', 'Archetype', 'Performance_Score'], ascending=[True, True, False])
               .groupby(['Season', 'Archetype'])
               .head(1))

# DISPLAY THE RESULTS IN A CLEAN FORMAT
pd.set_option('display.max_rows', None) # Ensure we see all years
result_list = top_players[['Season', 'Archetype', 'Player', 'Squad', 'Performance_Score']]

print("--- TOP 3 PLAYERS PER ARCHETYPE PER SEASON ---")
print(result_list)

core_df['Off_Pct'] = core_df['Offense_Index'].rank(pct=True)
core_df['Def_Pct'] = core_df['Defense_Index'].rank(pct=True)
core_df['Prg_Pct'] = core_df['Progression_Index'].rank(pct=True)

def label_archetype(row):
    if row['Off_Pct'] > 0.7 and row['Prg_Pct'] > 0.7:
        return "Creative Engine"
    elif row['Def_Pct'] > 0.7 and row['Prg_Pct'] > 0.7:
        return "Deep-Lying Progressor"
    elif row['Def_Pct'] > 0.7 and row['Off_Pct'] < 0.4:
        return "Midfield Anchor"
    elif row['Off_Pct'] > 0.4 and row['Def_Pct'] > 0.4 and row['Prg_Pct'] > 0.4:
        return "Modern Box-to-Box"
    else:
        return "System Rotational"

core_df['Archetype'] = core_df.apply(label_archetype, axis=1)


# --- ICONIC PLAYER PROFILE COMPARISON (RADAR CHART) ---

# 1. Select specific metrics for the Radar Chart
radar_metrics = ['npxG_p90', 'xAG_p90', 'KP_p90', 'PPA_p90', 'TklInt_p90', 'PrgP_p90', 'FinalThird_p90']
radar_labels = ['npxG', 'xAG', 'Key Passes', 'Passes to PA', 'Tackles+Int', 'Prg Passes', 'Final 1/3 Passes']

# 2. Scale these metrics globally (0-100) for the radar visualization
radar_scaler = MinMaxScaler()
radar_data_scaled = core_df.copy()
radar_data_scaled[radar_metrics] = radar_scaler.fit_transform(radar_data_scaled[radar_metrics]) * 100

# 3. Extract the two iconic players
xhaka = radar_data_scaled[(radar_data_scaled['Player'].str.contains('Xhaka')) &
                          (radar_data_scaled['Season'] == '2017-2018')].iloc[0]

tielemans = radar_data_scaled[(radar_data_scaled['Player'].str.contains('Tielemans')) &
                              (radar_data_scaled['Season'] == '2024-2025')].iloc[0]

# 4. Prepare data for plotting (close the radar loop)
def get_radar_values(row, metrics):
    values = row[metrics].values.flatten().tolist()
    return values + [values[0]]

xhaka_values = get_radar_values(xhaka, radar_metrics)
tielemans_values = get_radar_values(tielemans, radar_metrics)
angles = np.linspace(0, 2 * np.pi, len(radar_labels) + 1)

# 5. Create the Radar Plot
plt.figure(figsize=(10, 10))
ax = plt.subplot(111, polar=True)

# Plot Xhaka
ax.plot(angles, xhaka_values, color='red', linewidth=2, label='Granit Xhaka (2017-18)')
ax.fill(angles, xhaka_values, color='red', alpha=0.1)

# Plot Tielemans
ax.plot(angles, tielemans_values, color='blue', linewidth=2, label='Youri Tielemans (2024-25)')
ax.fill(angles, tielemans_values, color='blue', alpha=0.1)

# Styling
ax.set_theta_offset(np.pi / 2)
ax.set_theta_direction(-1)
ax.set_thetagrids(np.degrees(angles[:-1]), radar_labels)
ax.set_ylim(0, 100)

plt.title('Iconic Player Comparison: The Evolution of the Box-to-Box Midfielder', size=15, y=1.08)
plt.legend(loc='upper right', bbox_to_anchor=(1.3, 1.1))

plt.savefig('xhaka_vs_tielemans_radar.png')
plt.show()